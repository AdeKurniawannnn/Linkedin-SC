# Agentic Query Builder - Convex Schema Documentation

## Overview
This document describes the Convex schema and mutations/queries for the Agentic Query Builder feature.

## Schema Tables

### 1. agentSessions

Stores configuration and state for each agentic query builder session.

**Fields:**
- `userId` (optional string): User identifier for multi-user support
- `persona` (string): Agent persona/role description
- `seedQuery` (string): Initial query/topic to explore
- `scoringMasterPrompt` (string): Prompt template for scoring queries
- `pass1Threshold` (number): Score threshold for Pass 1 (default: 70)
- `pass2Threshold` (number): Score threshold for Pass 2 (default: 60)
- `queryBudgetPerRound` (number): Max queries to generate per round (default: 10)
- `concurrencyLimit` (number): Max parallel operations (default: 5)
- `maxResultsPerQuery` (number): Results to fetch per query (default: 100)
- `currentRound` (number): Current iteration round
- `roundHistory` (array): Historical stats per round
  - `round` (number): Round number
  - `queriesGenerated` (number): Total queries created
  - `queriesPassedPass1` (number): Queries passing first filter
  - `queriesPassedPass2` (number): Queries passing second filter
  - `avgCompositeScore` (optional number): Average composite score
  - `timestamp` (number): Round completion time
- `status` (enum): Current session status
  - `idle`: Session created, not started
  - `generating_queries`: Creating new queries
  - `scoring_pass1`: Running initial quality filter
  - `scoring_pass2`: Running detailed quality check
  - `executing_queries`: Fetching results
  - `completed`: Session finished
  - `error`: Session encountered error
- `createdAt` (number): Creation timestamp
- `updatedAt` (number): Last modification timestamp
- `lastError` (optional string): Error message if status is error

**Indexes:**
- `by_user`: [userId, createdAt] - Find sessions by user
- `by_status`: [status] - Find sessions by status

---

### 2. generatedQueries

Stores individual queries generated by the agent, along with their scoring and execution results.

**Fields:**
- `sessionId` (id): Reference to parent agentSessions table
- `round` (number): Round number when query was generated
- `query` (string): The actual search query text
- `generationReasoning` (optional string): Why this query was generated

**Pass 1 Scoring (Quick Filter):**
- `pass1Score` (optional number): Relevance score (0-100)
- `pass1Status` (enum): `pending` | `passed` | `failed`
- `pass1Reasoning` (optional string): Why it passed/failed

**Pass 2 Scoring (Detailed Quality Check):**
- `pass2Score` (optional number): Quality score (0-100)
- `pass2Status` (optional enum): `pending` | `passed` | `failed`
- `pass2Reasoning` (optional string): Detailed quality assessment
- `pass2SampleResults` (optional array): Sample results from test execution
  - Uses `unifiedResultValidator` from schema

**Final Scoring:**
- `compositeScore` (optional number): Combined Pass1 + Pass2 score

**Execution:**
- `execStatus` (optional enum): `pending` | `running` | `completed` | `error`
- `fullResults` (optional array): Complete search results
  - Uses `unifiedResultValidator` from schema
- `resultsCount` (optional number): Total results fetched

**Timestamps:**
- `createdAt` (number): Creation timestamp
- `updatedAt` (number): Last modification timestamp

**Indexes:**
- `by_session`: [sessionId, createdAt] - All queries for a session
- `by_session_status`: [sessionId, pass1Status] - Filter by status
- `by_composite_score`: [sessionId, compositeScore] - Sort by score

---

## API Functions

### agentSessions.ts

**Queries:**
- `get(id)`: Get single session by ID
- `getByUser(userId?, limit?)`: Get sessions for user
- `getActive(userId?)`: Get non-completed sessions
- `list(limit?)`: List all sessions

**Mutations:**
- `create({userId?, persona, seedQuery, scoringMasterPrompt, ...config})`: Create new session
- `update(id, {...config})`: Update session configuration
- `updateStatus(id, status, lastError?)`: Change session status
- `completeRound(id, roundStats)`: Finish round and update history
- `remove(id)`: Delete session and all associated queries

---

### generatedQueries.ts

**Queries:**
- `getBySession(sessionId, limit?)`: Get all queries for session
- `getBySessionAndRound(sessionId, round)`: Get queries for specific round
- `getTopByCompositeScore(sessionId, limit?)`: Get highest scoring queries
- `getByStatus(sessionId, pass1Status, limit?)`: Filter by pass1 status

**Mutations:**
- `addBatch(sessionId, round, queries[])`: Insert multiple queries at once
- `updatePass1(id, pass1Score, pass1Status, pass1Reasoning?)`: Update Pass 1 results
- `updatePass2(id, pass2Score, pass2Status, pass2Reasoning?, pass2SampleResults?, compositeScore)`: Update Pass 2 results
- `updateExecution(id, execStatus, fullResults?, resultsCount?)`: Update execution results
- `deleteBatch(sessionId, round?)`: Delete queries (all or specific round)

---

## Usage Example

```typescript
// 1. Create a session
const sessionId = await agentSessions.create({
  persona: "LinkedIn recruiter finding software engineers",
  seedQuery: "senior software engineer San Francisco",
  scoringMasterPrompt: "Evaluate query for finding qualified candidates...",
  pass1Threshold: 75,
  pass2Threshold: 65,
  queryBudgetPerRound: 10
});

// 2. Update status to generating
await agentSessions.updateStatus(sessionId, "generating_queries");

// 3. Add generated queries
await generatedQueries.addBatch(sessionId, 1, [
  { query: "senior software engineer startup San Francisco", generationReasoning: "..." },
  { query: "lead engineer SaaS Bay Area", generationReasoning: "..." }
]);

// 4. Update Pass 1 scores
const queries = await generatedQueries.getBySessionAndRound(sessionId, 1);
for (const query of queries) {
  await generatedQueries.updatePass1(query._id, 85, "passed", "Strong relevance");
}

// 5. Update Pass 2 scores
const passedQueries = await generatedQueries.getByStatus(sessionId, "passed");
for (const query of passedQueries) {
  await generatedQueries.updatePass2(
    query._id,
    78,
    "passed",
    "High quality results",
    sampleResults,
    81.5  // composite score
  );
}

// 6. Execute top queries
const topQueries = await generatedQueries.getTopByCompositeScore(sessionId, 5);
for (const query of topQueries) {
  await generatedQueries.updateExecution(query._id, "running");
  const results = await executeSearch(query.query);
  await generatedQueries.updateExecution(
    query._id,
    "completed",
    results,
    results.length
  );
}

// 7. Complete the round
await agentSessions.completeRound(sessionId, {
  queriesGenerated: 10,
  queriesPassedPass1: 8,
  queriesPassedPass2: 5,
  avgCompositeScore: 79.2
});

// 8. Mark session as completed
await agentSessions.updateStatus(sessionId, "completed");
```

---

## Design Patterns

### 1. Status Flow
```
Session Status Flow:
idle → generating_queries → scoring_pass1 → scoring_pass2 → executing_queries → completed
                                                                                  ↓
                                                                               error
```

### 2. Query Lifecycle
```
Query Lifecycle:
1. Created with pass1Status="pending"
2. Pass 1 scored → pass1Status="passed|failed"
3. If passed → Pass 2 scored → pass2Status="passed|failed"
4. If passed → execStatus="pending" → "running" → "completed"
```

### 3. Batch Operations
- Use `addBatch` to insert multiple queries atomically
- Use `deleteBatch` to clean up entire rounds or sessions
- Queries are automatically deleted when parent session is removed

### 4. Composite Scoring
```typescript
// Example composite score calculation
compositeScore = (pass1Score * 0.4) + (pass2Score * 0.6)
```

---

## Indexes Explained

### agentSessions
- `by_user`: Efficiently query sessions for a specific user, sorted by creation date
- `by_status`: Find all sessions in a specific state (e.g., all running sessions)

### generatedQueries
- `by_session`: Get all queries belonging to a session (primary relationship)
- `by_session_status`: Filter queries by pass1 status within a session
- `by_composite_score`: Sort queries by final score for ranking (descending order)

---

## Type Safety

All validators are exported and can be imported for type-safe API calls:

```typescript
import { api } from "./convex/_generated/api";
import type { Id } from "./convex/_generated/dataModel";

// Type-safe session ID
const sessionId: Id<"agentSessions"> = "...";

// Type-safe query
await useMutation(api.agentSessions.updateStatus)({
  id: sessionId,
  status: "generating_queries" // TypeScript ensures valid status
});
```

---

## Storage Considerations

- Each `generatedQueries` entry can store up to 100 results (`maxResultsPerQuery`)
- `pass2SampleResults` typically stores 5-10 sample results for evaluation
- `fullResults` stores all fetched results (can be large)
- Consider compressing or archiving completed sessions if storage becomes an issue
- Round history is stored inline in `agentSessions` for easy access

---

## Future Enhancements

- Add indexes for filtering by round number
- Add search index for full-text query search
- Add user preferences/templates for common personas
- Add session sharing between users
- Add export functionality for results
